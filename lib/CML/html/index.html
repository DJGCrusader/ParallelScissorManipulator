<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Copley Motion Library: Copley Motion Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Copley Motion Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Copley Motion Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro"></a>
Introduction</h1>
<p>The Copley Motion Library is a collection of C++ objects which are intended to simplify the development of CANopen and EtherCAT based products. These libraries allow low level access to the CANopen and EtherCAT networks while also providing high level methods for easy development of network based motion control applications.</p>
<h2><a class="anchor" id="platforms"></a>
Supported platforms</h2>
<p>The Copley Motion Library is designed to be highly platform independent. The only requirements of a platform are: </p>
<ul>
<li>C++ must be supported. The Copley Motion Library makes heavy use of the object oriented features of the C++ language. Porting it to standard C would require significant effort. </li>
<li>Multi-tasking. The library uses multiple threads of execution. For this reason, some type of multi-tasking operating system is required. A real time operating system is desirable, but not necessary. </li>
<li>Network hardware. Some sort of CAN hardware must be available for CANopen support. An Ethernet port must be available for EtherCAT support.</li>
</ul>
<p>The majority of the library code should be easily portable across platforms, even to those systems that do not have a very complete C++ implementation. In particular, the standard C and C++ libraries have been avoided to the extent possible.</p>
<h2><a class="anchor" id="mt"></a>
Multi-tasking support</h2>
<p>The C++ language does not define any standard method for multi-tasking, so a generic multi-tasking layer has been defined for use by this library. Three classes have been defined in the header file <a class="el" href="CML__Threads_8h.html" title="The classes defined in this file provide an operating system independent way of accessing multi-taski...">CML_Threads.h</a> which define the multi-tasking interface. These classes are; </p>
<ul>
<li><a class="el" href="classThread.html" title="Virtual class which provides multi-tasking. ">Thread</a>: An independent thread of execution. </li>
<li><a class="el" href="classMutex.html" title="This class represents an object that can be used by multiple threads to gain safe access to a shared ...">Mutex</a>: A mechanism used to provide mutually exclusive access to a variable or system resource. </li>
<li><a class="el" href="classSemaphore.html" title="Generic semaphore class. ">Semaphore</a>: A mechanism used to control access to a resource pool. This object allows threads to pend on it with timeouts.</li>
</ul>
<p>When porting the library to a new environment, these three objects will need to be implemented for that environment. The libraries currently support multi-tasking under posix compatible operating systems (most Unix varieties including Linux), and MS Windows.</p>
<h2><a class="anchor" id="canhardware"></a>
CAN hardware support</h2>
<p>The Copley Motion Libraries have been designed to use a generic interface to the low level CAN network hardware. This makes porting the libraries to new CAN hardware very straight forward. All CAN hardware access is routed through the <a class="el" href="classCanInterface.html" title="Abstract class used for low level interaction with CAN hardware. ">CanInterface</a> object defined in the header file <a class="el" href="CML__Can_8h.html" title="This file contains the base classes used to define the low level interface to the CAN network hardwar...">CML_Can.h</a>. This object defines generic methods to open, close, read from, and write to the CAN network. Adding support for new CAN interface hardware is as simple as implementing a new <a class="el" href="classCanInterface.html" title="Abstract class used for low level interaction with CAN hardware. ">CanInterface</a> object derived from this class.</p>
<h2><a class="anchor" id="ecathardware"></a>
EtherCAT hardware support</h2>
<p>When communicating over an EtherCAT network, CML uses the standard operating system API calls to access the Ethernet hardware. No special device drivers other then those normally used to access the Ethernet hardware are required.</p>
<p>Note that EtherCAT requires a dedicated Ethernet port. It is generally not possible to share a single Ethernet port for both a EtherCAT and general Ethernet communications at the same time.</p>
<h1><a class="anchor" id="CANopenBasics"></a>
CANopen basics</h1>
<p>CAN (Control Area Network) is a serial network originally developed for use in the automotive industry. The physical layer of CAN consists of a two wire differentially driven bus, typically terminated with 120 Ohm resisters on each end. The maximum bit rate supported by CAN is 1,000,000 bits/second for up to 25 meters. Lower bit rates may be used for longer network lengths.</p>
<p>Communication over the CAN bus takes the form of network packets. Each packet consists of an identifier, some control bits, and zero to eight bytes of data. Each packet is sent with CRC information which allows the CAN controllers on the network to identify and re-send incorrectly formatted packets.</p>
<p>The identifier sent with each CAN packet identifies the type of packet being sent, as well as the priority of the packet. If two or more devices on the network attempt to transmit packets at the same time, the one sending the higher priority packet will succeed. The device sending the lower priority packet will detect the network collision and automatically back off the network and re-try the transmission later. The fact that the higher priority packet is transmitted when a network collision occurs allows very high network bandwidth utilization. Other network technologies (such as Ethernet) would require both transmitting devices to abort their transmissions if a network collision was detected.</p>
<p>CANopen is a high level protocol used to communicate over a CAN network. It allows blocks of data larger then the eight byte CAN limit to be transmitted as a single entity. Additionally, CANopen defines a standard framework for device operation which simplifies communication between dissimilar devices.</p>
<p>In most cases a CANopen network consists of one master device, and multiple slave devices (also called network nodes). Each of the nodes on the network has a 7-bit node ID number associated with it in the range 1 to 127 (the node ID 0 is reserved, and should not be used). The Copley Motion Libraries are designed to run on the CANopen network master.</p>
<h2><a class="anchor" id="od"></a>
CANopen Object Dictionary</h2>
<p>One of the central concepts defined by the CANopen protocol is the notion of an object dictionary. This is essentially a collection of parameters on each device which define it's configuration and status. Most communication over the CANopen network consists of uploading data to, and downloading data from the object dictionaries of the various devices.</p>
<p>Each entry in the object dictionary is accessed using a 16-bit index value. Most entries in a device's object dictionary are simple atomic types (16-bit integers, 32-bit integers, strings, etc), however entries may be defined as complex types (records or arrays). In this case, the individual elements in the record or array are accessed using an additional 8-bit sub-index. It is not possible for these objects to be of complex types, so nesting of structures is not allowed.</p>
<h2><a class="anchor" id="sdo"></a>
SDO</h2>
<p>The majority of traffic over the CANopen network consists of the network master reading and writing to the object dictionaries of the slave devices (nodes) on the network. The primary mechanism through which this is accomplished is the Service Data Object (SDO).</p>
<p>Each node on the CANopen network is required to implement at least one SDO. The SDO is essentially a channel that can be opened between a network master and a slave for the purpose of reading from and writing to the slave's object dictionary.</p>
<p>SDO transfers are always initiated by the master, and always confirmed by the slave. The synchronous nature of the SDO makes error detection very straight forward. However, since every transfer using an SDO takes at least two CAN messages (one from the master to the slave, one from the slave to the master) they can be somewhat slow for the transfer of real time information.</p>
<p>For example, for the network master to update an object which holds an eight byte long value, six CAN messages will be required: </p>
<ul>
<li>1.The master sends a message to the slave indicating it's intentions to update the object. In this message it sends the object's index and sub-index values. It also passes the size (in bytes) of the data that will be transferred. </li>
<li>2.The slave responds to the master indicating that it is ready to receive the data. </li>
<li>3.The master sends the first 7 bytes of data. SDO transfers use one byte of the CAN message data for header information, so the largest amount of data that can be passed in any single message is 7 bytes. </li>
<li>4.The slave responds indicating that it received the data and is ready for more. </li>
<li>5.The master sends the remaining byte of data. </li>
<li>6.The slave responds indicating success.</li>
</ul>
<h2><a class="anchor" id="pdo"></a>
PDO</h2>
<p>A second method of accessing the data in the node's object dictionaries is defined by CANopen. This method is called the Process Data Object (PDO) and is primarily used to transfer frequently changing real-time data.</p>
<p>Unlike an SDO, a PDO can be initiated by either the network master, or the slave device. In fact, unlike SDO transfers, PDO transfers do not really follow a master - slave model. Any device on the network can initiate a PDO transfer, and a PDO message can be received and processed by multiple devices on the network.</p>
<p>Every PDO message consists of exactly one CAN message. Unlike SDO transfers, there is no confirmation with PDO transfers. This has the benefit of making much better use of the CAN network bandwidth, but since there is no response to a PDO, some other mechanism must be found to determine if the message was received successfully.</p>
<p>For example, updating the value of an 8-byte long variable in a device's object dictionary using a PDO can be accomplished in one CAN message, unlike the 6 messages that it required using SDO transfers. </p>
<ul>
<li>1.The master sends a CAN message containing the 8-bytes of data. No additional header information is passed in the message, and no response is sent.</li>
</ul>
<p>Of course, since all 8 bytes of the CAN message data were used to hold the object's value, there is no place the transmit the index / sub-index of the object being updated. This information must be implied based on the CAN message ID associated with the PDO. To create this association, a PDO must be mapped to one or more objects in a device's object dictionary before it can be used. This is accomplished by using SDO transfers, and effectively tells the device which object(s) a particular PDO transfer will access.</p>
<p>The result is that sending a PDO like in the above example requires a bit of setup using SDO transfers. It's therefore not useful to use a PDO transfer to update an object's value just once, since this could be more efficiently done using a single SDO transfer. However, if a particular object needs to be updated repeatedly, then the overhead of mapping a PDO to it makes more sense.</p>
<p>Aside from efficiency issues, PDO transfers have some other useful features. SDO transfers are inherently one master to one slave. PDO transfers can be used to broadcast a message to multiple other devices on the network. This is useful for synchronizing the start of a multi-axis move, for example.</p>
<p>Additionally, a slave device can be configured to transmit the value of one (or more) of the objects in it's object dictionary either at a set frequency, or when some internal event occurs. This would also be accomplished using PDO transfers.</p>
<h2><a class="anchor" id="nmt"></a>
Network management</h2>
<p>Most communication over the CANopen network consists of reading and writing values to a device's object dictionary using either SDO or PDO transfers. There are however several other message types which are required by the CANopen protocol.</p>
<p>Network management messages are used to control the state of the devices on the CANopen network. Every CANopen device implements a simple state machine which is controlled through the use of these messages. The following states are defined: </p>
<ul>
<li>Pre-operational: Every node enters this state after power-up or reset. In this state, the device is not functional, but will communicate over the CANopen network. PDO transfers are not allowed in pre-operational state, but SDO transfers may be used. </li>
<li>Operational: This is the normal operating state for all devices. SDO and PDO transfers are both allowed. </li>
<li>Stopped: No communication is allowed in this state except for network management messages. Neither SDO nor PDO transfers may be used.</li>
</ul>
<p>One use of network management messages is to control these state changes on the network devices. The following network management messages are sent by the network manager to control these state changes. Each of these messages can be either sent to a single node (by node ID), or broadcast to all the nodes on the network. </p>
<ul>
<li>Reset. This message causes the receiving node(s) to perform a soft reset and come up in pre-operation state. </li>
<li>Reset communications. Causes the receiving node(s) to reset their CANopen network to it's power-on state, and enter pre-operational state. This is not a full device reset, just a reset of the CANopen interface. </li>
<li>Pre-operational. This message causes the receiving node(s) to enter pre-operational state. No reset is performed. </li>
<li>Start. Causes the node(s) to enter operational state. </li>
<li>Stop. Causes the node(s) to enter stopped state.</li>
</ul>
<p>In addition to controlling the device's state machines, network management messages can be used to monitor the operation of the nodes on the CANopen network. There are two protocols to perform this task; heartbeat and node guarding.</p>
<p>The heartbeat protocol is very simple, the network master configures the node to transmit a heartbeat message at some interval. The heartbeat message is then sent by the node at the specified frequency. The only information passed in the heartbeat message is the current state of the node (i.e. pre-operational, operational or stopped). The network manager can monitor these messages, and if anything happens to the node (or the network connection to the node) it can detect this by the lack of heartbeat messages.</p>
<p>Node guarding is similar. The network manager configures the node to expect node guarding messages at some interval. The network manager then sends a message to the configured node at that frequency, and the node responds with a node guarding message. This allows both the network manager and slave device to identify a network failure if the guarding messages stop.</p>
<h2><a class="anchor" id="sync"></a>
SYNC messages</h2>
<p>Another type of message defined by the CANopen protocol is the SYNC message. This is a message that one device is configured to transmit at some interval, and that all other devices on the network receive. It can be used for device synchronization, and PDO transfers can be configured to be sent in response to the SYNC event.</p>
<p>Every CANopen network should have one (and only one) device which is configured to produce SYNC messages (the SYNC producer). Other devices on the network which receive the SYNC messages are SYNC consumers.</p>
<p>Copley Controls amplifiers are able to be configured as both SYNC producers and SYNC consumers. The default configuration for every amplifier after reset is as a SYNC consumer. The Copley Motion Library <a class="el" href="classAmp.html" title="Copley Controls amplifier object. ">Amp</a> class constructor will configure one of the amplifiers as a SYNC producer by default.</p>
<h2><a class="anchor" id="emcy"></a>
Emergency messages</h2>
<p>Emergency messages are sent by CANopen devices when some error condition is detected. They contain information about the type of error condition as well as manufacturer specific information not defined by the CANopen spec.</p>
<h1><a class="anchor" id="ecbasics"></a>
EtherCAT basics</h1>
<p>The EtherCAT network is a high performance field bus based on the Ethernet physical layer. There are several different high level protocols that can be implemented on top of EtherCAT, but the most common protocol, and the one supported by CML, is the CANopen over EtherCAT (CoE) protocol. When using this protocol, the EtherCAT network acts very much like a high speed CANopen network supporting an object dictionary, SDO and PDO access just like in CANopen.</p>
<p>One significant difference between the EtherCAT network and CANopen network is that in the CANopen network the nodes are able to transmit their status updates any time they like. In the EtherCAT network the network master needs to poll the status of the nodes.</p>
<h1><a class="anchor" id="overview"></a>
Architectural overview</h1>
<p>The Copley Motion Libraries are made up of a large number of classes, but several are of primary importance and will be used for every program. This section gives a brief overview of the most important of these classes. Detailed documentation of each of the provided classes is provided later in the manual.</p>
<h2><a class="anchor" id="can"></a>
CanInterface</h2>
<p>This class has already been mentioned above. It is one of the few classes that is highly platform dependent. The <a class="el" href="classCanInterface.html" title="Abstract class used for low level interaction with CAN hardware. ">CanInterface</a> class is used to abstract the CAN network interface hardware available on the system.</p>
<p>Typically, one of the first objects created in a program using the Copley Motion Libraries is a <a class="el" href="classCanInterface.html" title="Abstract class used for low level interaction with CAN hardware. ">CanInterface</a> object. This will in turn be passed to the <a class="el" href="classCanOpen.html" title="The CanOpen class is the top level interface into the CANopen network. ">CanOpen</a> object.</p>
<h2><a class="anchor" id="echw"></a>
EtherCatHardware</h2>
<p>This class is the generic representation of the Ethernet hardware interface used by the operating system. Like the <a class="el" href="classCanInterface.html" title="Abstract class used for low level interaction with CAN hardware. ">CanInterface</a> object, the exact details of this class's implementation will be different depending on the operating system being used.</p>
<h2><a class="anchor" id="net"></a>
Network class</h2>
<p>The <a class="el" href="classNetwork.html" title="Abstract network class. ">Network</a> class represents an EtherCAT or CANopen network.</p>
<h2><a class="anchor" id="co"></a>
CanOpen class</h2>
<p>The <a class="el" href="classCanOpen.html" title="The CanOpen class is the top level interface into the CANopen network. ">CanOpen</a> class is derived from the <a class="el" href="classNetwork.html" title="Abstract network class. ">Network</a> class and represents the CANopen network. The Open method of this class must be called before the class can be used. This method takes a reference to a <a class="el" href="classCanInterface.html" title="Abstract class used for low level interaction with CAN hardware. ">CanInterface</a> object as it's only parameter. The <a class="el" href="classCanOpen.html" title="The CanOpen class is the top level interface into the CANopen network. ">CanOpen</a> class will then attempt to open the CAN interface (by calling <a class="el" href="classCanInterface.html#a8b0ab47ca76d8fa64b7306212dd1cc4a" title="Open the CAN interface. ">CanInterface::Open</a> method), and if that is successful it will start a new thread which will be responsible for reading messages from the CAN interface.</p>
<p>It is possible to have more then one <a class="el" href="classCanOpen.html" title="The CanOpen class is the top level interface into the CANopen network. ">CanOpen</a> object in a system. Each should be connected to a distinct CAN network, and each should therefore be passed a distinct <a class="el" href="classCanInterface.html" title="Abstract class used for low level interaction with CAN hardware. ">CanInterface</a> object.</p>
<p>The primary responsibility of the <a class="el" href="classCanOpen.html" title="The CanOpen class is the top level interface into the CANopen network. ">CanOpen</a> object is to listen for messages on the CAN network. To perform this task, the <a class="el" href="classCanOpen.html" title="The CanOpen class is the top level interface into the CANopen network. ">CanOpen</a> object creates a separate high priority thread which constantly monitors the CAN network for new messages. Every time a new message is received, the read thread searches for a <a class="el" href="classReceiver.html" title="CANopen receiver object. ">Receiver</a> object associated with the message's CAN ID. If such an object is found, it's handler method is called to process the message.</p>
<h2><a class="anchor" id="ecatclass"></a>
EtherCAT class</h2>
<p>The <a class="el" href="classEtherCAT.html" title="The EtherCAT class is the top level interface into the EtherCAT network. ">EtherCAT</a> class is derived from the <a class="el" href="classNetwork.html" title="Abstract network class. ">Network</a> class and represents the EtherCAT network. The Open method of this class must be called before the class can be used. This method takes a reference to a <a class="el" href="classEtherCatHardware.html" title="Low level Ethernet hardware interface. ">EtherCatHardware</a> object as it's only parameter. That object will be used to perform the low level communications with the Ethernet hardware.</p>
<h2><a class="anchor" id="rcvr"></a>
Receiver class</h2>
<p><a class="el" href="classReceiver.html" title="CANopen receiver object. ">Receiver</a> objects are used to listen for messages on the CAN network. Each <a class="el" href="classReceiver.html" title="CANopen receiver object. ">Receiver</a> object has a CAN message ID associated with it. When a message is received which has this ID value, the <a class="el" href="classCanOpen.html" title="The CanOpen class is the top level interface into the CANopen network. ">CanOpen</a> object will search for a <a class="el" href="classReceiver.html" title="CANopen receiver object. ">Receiver</a> object with that ID. If no such <a class="el" href="classReceiver.html" title="CANopen receiver object. ">Receiver</a> is found, the message will be ignored. If a <a class="el" href="classReceiver.html" title="CANopen receiver object. ">Receiver</a> object with a matching ID is found, then the virtual <a class="el" href="classReceiver.html#ad250e761b353af6cda60f1b61e229c99" title="Process a new received CAN bus frame. ">Receiver::NewFrame()</a> method will be called.</p>
<h2><a class="anchor" id="node"></a>
Node class</h2>
<p>The <a class="el" href="classNode.html" title="Node class. ">Node</a> class represents a node (slave device) on the CANopen network. This class is passed a node ID value, and a reference to a <a class="el" href="classCanOpen.html" title="The CanOpen class is the top level interface into the CANopen network. ">CanOpen</a> object during construction. The <a class="el" href="classCanOpen.html" title="The CanOpen class is the top level interface into the CANopen network. ">CanOpen</a> object identifies which network the <a class="el" href="classNode.html" title="Node class. ">Node</a> is connected to.</p>
<p>The <a class="el" href="classNode.html" title="Node class. ">Node</a> class defines various methods to read and write standard objects from the node's object dictionary. The objects that are built into the <a class="el" href="classNode.html" title="Node class. ">Node</a> class are those that are defined in the CANopen communication specification (DS301).</p>
<p>The <a class="el" href="classNode.html" title="Node class. ">Node</a> class also includes logic which allows it to transmit and monitor the node guarding (or heartbeat) protocols for the device on the network. If the device being monitored stops responding, or changes state, the virtual method HandleStateChange() will be called. By default this does nothing, but it may be extended to perform any necessary action to handle the condition.</p>
<h2><a class="anchor" id="amp"></a>
Amp class</h2>
<p>The <a class="el" href="classAmp.html" title="Copley Controls amplifier object. ">Amp</a> inherits from the <a class="el" href="classNode.html" title="Node class. ">Node</a> class, and is used to represent a Copley Controls amplifier on the CANopen network. This class includes numerous methods used to get and set various amplifier parameters. The <a class="el" href="classAmp.html" title="Copley Controls amplifier object. ">Amp</a> class also includes several high level methods used to make point to point moves, home the amplifier, and stream complex PVT style profiles down to the amplifier. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<hr>
<address style="align: right;">
<small>Copley Motion Library, Copyright (c) 2002-2003
<a href="http://www.copleycontrols.com">
<img src="CCC_logo.gif" alt="Copley Controls Corp." align="middle" border=0 ></a>
</small>
</address>
</body>
</html>
