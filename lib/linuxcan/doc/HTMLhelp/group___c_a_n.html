<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Kvaser Linux CANLIB: CAN</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Kvaser Linux CANLIB</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group___c_a_n.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>CAN</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcan_notify_data.html">canNotifyData</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structcan_notify_data.html">canNotifyData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#ga58db5be8859c14cd8a0c0f6963c64f26">canNotifyData</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#ga49525373a4d08d93c651ec10f79dd36b">canClose</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#ga99c7c99cc71580f8099a1407f4f9ea1a">canBusOn</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#gaf1786cfbfd542b18b9c599d278837bd9">canBusOff</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#ga7eb8c2e92cfae57e7ec5031818524301">canSetBusParams</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd, long freq, unsigned int tseg1, unsigned int tseg2, unsigned int sjw, unsigned int noSamp, unsigned int syncmode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#gaf2a734c0486030610389331685a3827a">canGetBusParams</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd, long *freq, unsigned int *tseg1, unsigned int *tseg2, unsigned int *sjw, unsigned int *noSamp, unsigned int *syncmode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#gafca31590718ac7101d065b0c18b2410e">canSetBusOutputControl</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd, const unsigned int drivertype)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#ga1683419d56af8afdbfc9184678c82fdd">canGetBusOutputControl</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd, unsigned int *drivertype)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#gaa4ffd2fad1932ad5763c2c923a1a12d8">canAccept</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd, const long envelope, const unsigned int flag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#gaca3da209fe673b3838a50a3abe831855">canReadStatus</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd, unsigned long *const flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#gadb3a712bd123317043cb73e1008075c8">canReadErrorCounters</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd, unsigned int *txErr, unsigned int *rxErr, unsigned int *ovErr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#ga62c185329d6741c90102511e2f37983e">canWrite</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd, long id, void *msg, unsigned int dlc, unsigned int flag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#ga304cb3a7bc2874c1f8ad361a911bcd5f">canWriteSync</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd, unsigned long timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#ga157d49a9343dea68ac953145e02266d8">canRead</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd, long *id, void *msg, unsigned int *dlc, unsigned int *flag, unsigned long *time)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#gac01f98e282609b5f6aaf2b1eabfb83ec">canReadWait</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd, long *id, void *msg, unsigned int *dlc, unsigned int *flag, unsigned long *time, unsigned long timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#ga16356f4d646240ff2e640773d21f4d76">canReadSync</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd, unsigned long timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#gaa5dd0f277c7059169055321fbda87486">canSetNotify</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd, void(*callback)(<a class="el" href="structcan_notify_data.html">canNotifyData</a> *), unsigned int notifyFlags, void *tag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#gaa1229ae7635c051a8f7fe545d9d8007a">canGetRawHandle</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd, void *pvFd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#gaf38b95fce4930347d9986887ec046e13">canTranslateBaud</a> (long *const freq, unsigned int *const tseg1, unsigned int *const tseg2, unsigned int *const sjw, unsigned int *const nosamp, unsigned int *const syncMode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#ga04c2f80a23b992bf17591749192e8d48">canReadTimer</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd, unsigned long *time)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#gac377d182232fb4ec2fed881c2b9ab300">canOpenChannel</a> (int channel, int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#ga1a3ba0ef73eee6b97e886730ac696935">canSetBusParamsC200</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd, <a class="el" href="canlib_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> btr0, <a class="el" href="canlib_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> btr1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#gaecc8b56e75cf68548af53b2d432079af">canResetBus</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#ga47d03bfcc31e290284e65211b61f15f3">canWriteWait</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd, long id, void *msg, unsigned int dlc, unsigned int flag, unsigned long timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#ga7abcf8f512da6ab568850b9faa0bc28b">canFlushReceiveQueue</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n.html#ga52a17bb8012bf025d127b4d29e5f3aa8">canFlushTransmitQueue</a> (const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> hnd)</td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga58db5be8859c14cd8a0c0f6963c64f26"></a><!-- doxytag: member="canlib.h::canNotifyData" ref="ga58db5be8859c14cd8a0c0f6963c64f26" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structcan_notify_data.html">canNotifyData</a>  <a class="el" href="structcan_notify_data.html">canNotifyData</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaa4ffd2fad1932ad5763c2c923a1a12d8"></a><!-- doxytag: member="canlib.h::canAccept" ref="gaa4ffd2fad1932ad5763c2c923a1a12d8" args="(const CanHandle hnd, const long envelope, const unsigned int flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canAccept </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>envelope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine sets the message acceptance filters on a CAN channel.</p>
<p>On some boards the acceptance filtering is done by the CAN hardware; on other boards (typically those with an embedded CPU,) the acceptance filtering is done by software. <a class="el" href="group___c_a_n.html#gaa4ffd2fad1932ad5763c2c923a1a12d8">canAccept()</a> behaves in the same way for all boards, however.</p>
<p>canSetAcceptanceFilter() and <a class="el" href="group___c_a_n.html#gaa4ffd2fad1932ad5763c2c923a1a12d8">canAccept()</a> both serve the same purpose but the former can set the code and mask in just one call.</p>
<p>If you want to remove a filter, call <a class="el" href="group___c_a_n.html#gaa4ffd2fad1932ad5763c2c923a1a12d8">canAccept()</a> with the mask set to 0.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>You can set the extended code and mask only on CAN boards that support extended identifiers.</dd>
<dd>
Not all CAN boards support different masks for standard and extended CAN identifiers.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>An open handle to a CAN circuit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">envelope</td><td>The mask or code to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>Any of <a class="el" href="canlib_8h.html#a9485f417c3629b9eb72d673b3ff16a5f">canFILTER_SET_CODE_STD</a>, <a class="el" href="canlib_8h.html#a8665c92e40adccfacc238af38b39f37e">canFILTER_SET_MASK_STD</a>, <a class="el" href="canlib_8h.html#a17172d69415cf42d7db3417d8109ec9f">canFILTER_SET_CODE_EXT</a> or <a class="el" href="canlib_8h.html#a3f55cdaf15a7d72f34e38d3b32a479c5">canFILTER_SET_MASK_EXT</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if success </dd>
<dd>
canERR_xxx (negative) if failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="page_user_guide_misc_code_and_mask.html">Code and Mask Format</a>, <a class="el" href="page_user_guide_send_recv_filters.html">Message Filters</a>, <a class="el" href="page_code_snippets_examples.html">Code Examples</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf1786cfbfd542b18b9c599d278837bd9"></a><!-- doxytag: member="canlib.h::canBusOff" ref="gaf1786cfbfd542b18b9c599d278837bd9" args="(const CanHandle hnd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canBusOff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Takes the specified channel off-bus.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>An open handle to a CAN channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if success </dd>
<dd>
canERR_xxx (negative) if failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="page_code_snippets_examples.html">Code Examples</a> </dd>
<dd>
<a class="el" href="group___c_a_n.html#ga99c7c99cc71580f8099a1407f4f9ea1a">canBusOn()</a>, <a class="el" href="group___c_a_n.html#gaecc8b56e75cf68548af53b2d432079af">canResetBus()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="opentest_8c-example.html#a8">opentest.c</a>, <a class="el" href="simplewrite_8c-example.html#a6">simplewrite.c</a>, and <a class="el" href="writeloop_8c-example.html#a11">writeloop.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga99c7c99cc71580f8099a1407f4f9ea1a"></a><!-- doxytag: member="canlib.h::canBusOn" ref="ga99c7c99cc71580f8099a1407f4f9ea1a" args="(const CanHandle hnd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canBusOn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Takes the specified channel on-bus.</p>
<p>If you are using multiple handles to the same physical channel, for example if you are writing a threaded application, you must call <a class="el" href="group___c_a_n.html#ga99c7c99cc71580f8099a1407f4f9ea1a">canBusOn()</a> once for each handle. The same applies to <a class="el" href="group___c_a_n.html#gaf1786cfbfd542b18b9c599d278837bd9">canBusOff()</a> - the physical channel will not go off bus until the last handle to the channel goes off bus.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>An open handle to a CAN channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if success </dd>
<dd>
canERR_xxx (negative) if failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="page_code_snippets_examples.html">Code Examples</a> </dd>
<dd>
<a class="el" href="group___c_a_n.html#gaf1786cfbfd542b18b9c599d278837bd9">canBusOff()</a>, <a class="el" href="group___c_a_n.html#gaecc8b56e75cf68548af53b2d432079af">canResetBus()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cancount_8c-example.html#a7">cancount.c</a>, <a class="el" href="canmonitor_8c-example.html#a7">canmonitor.c</a>, <a class="el" href="opentest_8c-example.html#a7">opentest.c</a>, <a class="el" href="simplewrite_8c-example.html#a10">simplewrite.c</a>, and <a class="el" href="writeloop_8c-example.html#a7">writeloop.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga49525373a4d08d93c651ec10f79dd36b"></a><!-- doxytag: member="canlib.h::canClose" ref="ga49525373a4d08d93c651ec10f79dd36b" args="(const CanHandle hnd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canClose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Closes the channel associated with the handle. If no other threads are using the CAN circuit, it is taken off bus. The handle can not be used for further references to the channel, so any variable containing it should be zeroed.</p>
<p><a class="el" href="group___c_a_n.html#ga49525373a4d08d93c651ec10f79dd36b">canClose()</a> will almost always return <a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a>; the specified handle is closed on an best-effort basis.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>An open handle to a CAN channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if success </dd>
<dd>
canERR_xxx (negative) if failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="page_code_snippets_examples.html">Code Examples</a> </dd>
<dd>
<a class="el" href="group___c_a_n.html#gac377d182232fb4ec2fed881c2b9ab300">canOpenChannel()</a>, <a class="el" href="group___c_a_n.html#ga99c7c99cc71580f8099a1407f4f9ea1a">canBusOn()</a>, <a class="el" href="group___c_a_n.html#gaf1786cfbfd542b18b9c599d278837bd9">canBusOff()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="canmonitor_8c-example.html#a11">canmonitor.c</a>, <a class="el" href="opentest_8c-example.html#a9">opentest.c</a>, <a class="el" href="read_timer_test_8c-example.html#a4">readTimerTest.c</a>, <a class="el" href="simplewrite_8c-example.html#a13">simplewrite.c</a>, and <a class="el" href="writeloop_8c-example.html#a12">writeloop.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga7abcf8f512da6ab568850b9faa0bc28b"></a><!-- doxytag: member="canlib.h::canFlushReceiveQueue" ref="ga7abcf8f512da6ab568850b9faa0bc28b" args="(const CanHandle hnd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canFlushReceiveQueue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function removes all received messages from the handle's receive queue. Other handles open to the same channel are not affcted by this operation. That is, only the messages belonging to the handle you are passing to <a class="el" href="group___c_a_n.html#ga7abcf8f512da6ab568850b9faa0bc28b">canFlushReceiveQueue</a> are discarded.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This call has the same effect as calling <a class="el" href="group___general.html#gaeaa24db97af22478ca51d48636c7bb12">canIoCtl()</a> with a function code of <a class="el" href="canlib_8h.html#a1a07daae84b7fdcc3a90730530f9ca49">canIOCTL_FLUSH_RX_BUFFER</a>.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>A handle to an open circuit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if success </dd>
<dd>
canERR_xxx (negative) if failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group___c_a_n.html#ga52a17bb8012bf025d127b4d29e5f3aa8">canFlushTransmitQueue()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga52a17bb8012bf025d127b4d29e5f3aa8"></a><!-- doxytag: member="canlib.h::canFlushTransmitQueue" ref="ga52a17bb8012bf025d127b4d29e5f3aa8" args="(const CanHandle hnd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canFlushTransmitQueue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function removes all messages pending transmission from the transmit queue of the circuit.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If there are other handles open to the same circuit, they are also flushed.</dd>
<dd>
This call has the same effect as calling <a class="el" href="group___general.html#gaeaa24db97af22478ca51d48636c7bb12">canIoCtl()</a> with a function code of <a class="el" href="canlib_8h.html#af3e37bd778bfba0891046c4e279aea99">canIOCTL_FLUSH_TX_BUFFER</a>.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>A handle to an open circuit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if success </dd>
<dd>
canERR_xxx (negative) if failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group___c_a_n.html#ga7abcf8f512da6ab568850b9faa0bc28b">canFlushReceiveQueue()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1683419d56af8afdbfc9184678c82fdd"></a><!-- doxytag: member="canlib.h::canGetBusOutputControl" ref="ga1683419d56af8afdbfc9184678c82fdd" args="(const CanHandle hnd, unsigned int *drivertype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canGetBusOutputControl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>drivertype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves the current CAN controller driver type. This corresponds loosely to the bus output control register in the CAN controller, hence the name of this function. CANLIB does not allow for direct manipulation of the bus output control register; instead, symbolic constants are used to select the desired driver type.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Don't confuse the CAN controller driver type with the bus driver type. The CAN controller is not connected directly to the CAN bus; instead, it is connected to a bus transceiver circuit which interfaces directly to the bus. The "CAN controller driver type" we are talking about here refers to the mode which the CAN controller uses to drive the bus transceiver circuit.</dd>
<dd>
Silent Mode is not supported by all CAN controllers.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>An open handle to a CAN circuit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">drivertype</td><td>A pointer to an unsigned int which receives the current driver type. The driver type can be either <a class="el" href="canlib_8h.html#ae5d980394050f52fd4af8f8ca75a4bca">canDRIVER_NORMAL</a> or <a class="el" href="canlib_8h.html#ab82a818e60cddf4c65c54d42a474a023">canDRIVER_SILENT</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if success </dd>
<dd>
canERR_xxx (negative) if failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group___c_a_n.html#gafca31590718ac7101d065b0c18b2410e">canSetBusOutputControl()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2a734c0486030610389331685a3827a"></a><!-- doxytag: member="canlib.h::canGetBusParams" ref="gaf2a734c0486030610389331685a3827a" args="(const CanHandle hnd, long *freq, unsigned int *tseg1, unsigned int *tseg2, unsigned int *sjw, unsigned int *noSamp, unsigned int *syncmode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canGetBusParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>tseg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>tseg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>sjw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>noSamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>syncmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves the current bus parameters for the specified channel.</p>
<p>The anatomy of a CAN bit is discussed in detail at Kvaser's web site at <a href="http://www.kvaser.com">www.kvaser.com</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>An open handle to a CAN controller. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">freq</td><td>Bit rate (bits per second). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tseg1</td><td>Time segment 1, that is, the number of quanta from (but not including) the Sync Segment to the sampling point. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tseg2</td><td>Time segment 2, that is, the number of quanta from the sampling point to the end of the bit. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sjw</td><td>The Synchronization Jump Width; can be 1,2,3, or 4. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">noSamp</td><td>The number of sampling points; can be 1 or 3. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">syncmode</td><td>Unsupported, always read as zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if success </dd>
<dd>
canERR_xxx (negative) if failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="page_code_snippets_bit_rate.html">Bit Rate Examples</a>, <a class="el" href="page_user_guide_init_bit_rate.html">Bit Rate and Other Bus Parameters</a> </dd>
<dd>
<a class="el" href="group___c_a_n.html#ga7eb8c2e92cfae57e7ec5031818524301">canSetBusParams()</a>, <a class="el" href="group___c_a_n.html#ga1a3ba0ef73eee6b97e886730ac696935">canSetBusParamsC200()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="busparms_8c-example.html#a6">busparms.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaa1229ae7635c051a8f7fe545d9d8007a"></a><!-- doxytag: member="canlib.h::canGetRawHandle" ref="gaa1229ae7635c051a8f7fe545d9d8007a" args="(const CanHandle hnd, void *pvFd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canGetRawHandle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvFd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns raw handle/file descriptor for use in system calls. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Use this function with caution.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>CanHandle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvFd</td><td>Pointer to raw can data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if success </dd>
<dd>
canERR_xxx (negative) if failure </dd></dl>

</div>
</div>
<a class="anchor" id="gac377d182232fb4ec2fed881c2b9ab300"></a><!-- doxytag: member="canlib.h::canOpenChannel" ref="gac377d182232fb4ec2fed881c2b9ab300" args="(int channel, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a> canOpenChannel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Opens a CAN channel (circuit) and returns a handle which is used in subsequent calls to CANLIB.</p>
<p>Channel numbering is dependent on the installed hardware. The first channel always has number 0.</p>
<p>For example,</p>
<ul>
<li>If you have a single LAPcan, the channels are numbered 0 and 1.</li>
</ul>
<ul>
<li>If you have a USBcan Professional, the channels are numbered 0-1 according to the labels on the cables.</li>
</ul>
<ul>
<li>The virtual channels come after all physical channels.</li>
</ul>
<p>If you are using multiple threads, note that the returned handle is usable only in the context of the thread that created it. That is, you must call <a class="el" href="group___c_a_n.html#gac377d182232fb4ec2fed881c2b9ab300">canOpenChannel()</a> in each of the threads in your application that uses the CAN bus. You can open the same channel from multiple threads, but you must call <a class="el" href="group___c_a_n.html#gac377d182232fb4ec2fed881c2b9ab300">canOpenChannel()</a> once per thread.</p>
<p>If you are using the same channel via multiple handles, note that the default behaviour is that the different handles will "hear" each other just as if each handle referred to a channel of its own. If you open, say, channel 0 from thread A and thread B and then send a message from thread A, it will be "received" by thread B. This behaviour can be changed using <a class="el" href="canlib_8h.html#a86f7ce6c809f30983b69ead49d793689">canIOCTL_SET_LOCAL_TXECHO</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The handle returned may be zero which is perfectly valid.</dd>
<dd>
This call replaces the canOpen() API call and serves the same purpose.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>The number of the channel. Channel numbering is hardware dependent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>A combination of <a class="el" href="canlib_8h.html#canOPEN_xxx">canOPEN_xxx</a> flags</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a handle to the opened circuit, or canERR_xxx (negative) if the call failed.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="page_code_snippets_examples.html">Code Examples</a>, <a class="el" href="page_user_guide_virtual_info.html">Virtual Channels</a> </dd>
<dd>
<a class="el" href="group___general.html#ga65169ca633cd30aa92b8a80e28a5378b">canGetNumberOfChannels()</a>, <a class="el" href="group___general.html#gab9552d1a588b0dbc144b097acba017b2">canGetChannelData()</a>, <a class="el" href="group___general.html#gaeaa24db97af22478ca51d48636c7bb12">canIoCtl()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="busparms_8c-example.html#a2">busparms.c</a>, <a class="el" href="cancount_8c-example.html#a3">cancount.c</a>, <a class="el" href="canmonitor_8c-example.html#a1">canmonitor.c</a>, <a class="el" href="opentest_8c-example.html#a2">opentest.c</a>, <a class="el" href="read_timer_test_8c-example.html#a0">readTimerTest.c</a>, <a class="el" href="simplewrite_8c-example.html#a3">simplewrite.c</a>, and <a class="el" href="writeloop_8c-example.html#a1">writeloop.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga157d49a9343dea68ac953145e02266d8"></a><!-- doxytag: member="canlib.h::canRead" ref="ga157d49a9343dea68ac953145e02266d8" args="(const CanHandle hnd, long *id, void *msg, unsigned int *dlc, unsigned int *flag, unsigned long *time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canRead </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>dlc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads a message from the receive buffer. If no message is available, the function returns immediately with return code <a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a734089f351bc421c230bf8b6cd9b1e8e">canERR_NOMSG</a>.</p>
<p>If you are using the same channel via multiple handles, note that the default behaviour is that the different handles will "hear" each other just as if each handle referred to a channel of its own. If you open, say, channel 0 from thread A and thread B and then send a message from thread A, it will be "received" by thread B. This behaviour can be changed using <a class="el" href="canlib_8h.html#a86f7ce6c809f30983b69ead49d793689">canIOCTL_SET_LOCAL_TXECHO</a>.</p>
<p>It is allowed to pass <code>NULL</code> as the value of <em>id</em>, <em>msg</em>, <em>dlc</em>, <em>flag</em>, and <em>time</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>A handle to an open circuit. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>Pointer to a buffer which receives the CAN identifier. This buffer will only get the identifier. To determine whether this identifier was standard (11-bit) or extended (29-bit), and/or whether it was remote or not, or if it was an error frame, examine the contents of the flag argument. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">msg</td><td>Pointer to the buffer which receives the message data. This buffer must be large enough (i.e. 8 bytes.) Only the message data is copied; the rest of the buffer is left as-is. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dlc</td><td>Pointer to a buffer which receives the message length. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flag</td><td>Pointer to a buffer which receives the message flags, which is a combination of the canMSG_xxx and canMSGERR_xxx values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">time</td><td>Pointer to a buffer which receives the message time stamp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if a message was read. </dd>
<dd>
<a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a734089f351bc421c230bf8b6cd9b1e8e">canERR_NOMSG</a> (negative) if there was no message available. </dd>
<dd>
canERR_xxx (negative) if failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="page_user_guide_send_recv_reading.html">Reading Messages</a>, <a class="el" href="page_user_guide_send_recv_mailboxes.html">Message Mailboxes</a>, <a class="el" href="page_code_snippets_examples.html">Code Examples</a>, <a class="el" href="page_user_guide_time_accuracy_and_resolution.html">Time Stamping Accuracy and Resolution</a> </dd>
<dd>
canReadSpecific(), canReadSpecificSkip(), <a class="el" href="group___c_a_n.html#ga16356f4d646240ff2e640773d21f4d76">canReadSync()</a>, canReadSyncSpecific(), <a class="el" href="group___c_a_n.html#gac01f98e282609b5f6aaf2b1eabfb83ec">canReadWait()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadb3a712bd123317043cb73e1008075c8"></a><!-- doxytag: member="canlib.h::canReadErrorCounters" ref="gadb3a712bd123317043cb73e1008075c8" args="(const CanHandle hnd, unsigned int *txErr, unsigned int *rxErr, unsigned int *ovErr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canReadErrorCounters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>txErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>rxErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>ovErr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the error counters of the CAN controller.</p>
<p><a class="el" href="group___c_a_n.html#gadb3a712bd123317043cb73e1008075c8">canReadErrorCounters()</a> returns the latest known values of the error counters in the specified circuit. If the error counters change values precisely when <a class="el" href="group___c_a_n.html#gadb3a712bd123317043cb73e1008075c8">canReadErrorCounters()</a> is called, it may not be reflected in the returned result.</p>
<p>It is allowed to pass <code>NULL</code> as the value of the <em>txErr</em>, <em>rxErr</em>, and <em>ovErr</em> parameters.</p>
<p>Use <a class="el" href="group___general.html#gaeaa24db97af22478ca51d48636c7bb12">canIoCtl()</a> to clear the counters.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Not all CAN controllers provide access to the error counters; in this case, an educated guess is returned.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>A handle to an open circuit. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">txErr</td><td>A pointer to a <code>DWORD</code> which receives the transmit error counter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rxErr</td><td>A pointer to a <code>DWORD</code> which receives the receive error counter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ovErr</td><td>A pointer to a <code>DWORD</code> which receives the number of overrun errors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if success </dd>
<dd>
canERR_xxx (negative) if failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group___general.html#gaeaa24db97af22478ca51d48636c7bb12">canIoCtl()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaca3da209fe673b3838a50a3abe831855"></a><!-- doxytag: member="canlib.h::canReadStatus" ref="gaca3da209fe673b3838a50a3abe831855" args="(const CanHandle hnd, unsigned long *const flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canReadStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *const&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the status for the specified circuit. flags points to a longword which receives a combination of the canSTAT_xxx flags.</p>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="group___c_a_n.html#gaca3da209fe673b3838a50a3abe831855">canReadStatus()</a> returns the latest known status of the specified circuit. If a status change happens precisely when <a class="el" href="group___c_a_n.html#gaca3da209fe673b3838a50a3abe831855">canReadStatus()</a> is called, it may not be reflected in the returned result.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>A handle to an open circuit. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flags</td><td>Pointer to a <code>DWORD</code> which receives the status flags; this is a combination of any of the canSTAT_xxx.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if success </dd>
<dd>
canERR_xxx (negative) if failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga16356f4d646240ff2e640773d21f4d76"></a><!-- doxytag: member="canlib.h::canReadSync" ref="ga16356f4d646240ff2e640773d21f4d76" args="(const CanHandle hnd, unsigned long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canReadSync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Waits until the receive buffer contains at least one message or a timeout occurs.</p>
<p>If you are using the same channel via multiple handles, note that the default behaviour is that the different handles will "hear" each other just as if each handle referred to a channel of its own. If you open, say, channel 0 from thread A and thread B and then send a message from thread A, it will be "received" by thread B. This behaviour can be changed using <a class="el" href="canlib_8h.html#a86f7ce6c809f30983b69ead49d793689">canIOCTL_SET_LOCAL_TXECHO</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>A handle to an open circuit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>The timeout in milliseconds. 0xFFFFFFFF gives an infinite timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if the queue contains the desired message. </dd>
<dd>
<a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7acd1c4c3a87dd24f0a43753ee4bfe7993">canERR_TIMEOUT</a> (negative) if a timeout occurs before a message arrived. </dd>
<dd>
canERR_xxx (negative) if the call fails.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group___c_a_n.html#ga157d49a9343dea68ac953145e02266d8">canRead()</a>, <a class="el" href="group___c_a_n.html#gac01f98e282609b5f6aaf2b1eabfb83ec">canReadWait()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga04c2f80a23b992bf17591749192e8d48"></a><!-- doxytag: member="canlib.h::canReadTimer" ref="ga04c2f80a23b992bf17591749192e8d48" args="(const CanHandle hnd, unsigned long *time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canReadTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the current time from the clock used to timestamp the messages for the indicated circuit.</p>
<p>This API may return <a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a9335388ba5edd2cedeb61d6febeff505">canERR_INVHANDLE</a> and/or <a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a87887ebf2a17b06d82d83e33acf06df8">canERR_NOTINITIALIZED</a>! This happens if <em>hnd</em> is invalid, or if the library was not initialized.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The clock used to timestamp the messages may not be available for direct reading on all platforms. In such cases, the PC's clock is used to return an approximation of the current time. Note that clock drift might occur in this case.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>A handle to an open circuit. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">time</td><td>The current time, with the prevailing time resolution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if success </dd>
<dd>
canERR_xxx (negative) if failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="page_user_guide_time_accuracy_and_resolution.html">Time Stamping Accuracy and Resolution</a> </dd>
<dd>
kvReadTimer() </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="read_timer_test_8c-example.html#a2">readTimerTest.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gac01f98e282609b5f6aaf2b1eabfb83ec"></a><!-- doxytag: member="canlib.h::canReadWait" ref="gac01f98e282609b5f6aaf2b1eabfb83ec" args="(const CanHandle hnd, long *id, void *msg, unsigned int *dlc, unsigned int *flag, unsigned long *time, unsigned long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canReadWait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>dlc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads a message from the receive buffer. If no message is available, the function waits until a message arrives or a timeout occurs.</p>
<p>If you are using the same channel via multiple handles, note that the default behaviour is that the different handles will "hear" each other just as if each handle referred to a channel of its own. If you open, say, channel 0 from thread A and thread B and then send a message from thread A, it will be "received" by thread B. This behaviour can be changed using <a class="el" href="canlib_8h.html#a86f7ce6c809f30983b69ead49d793689">canIOCTL_SET_LOCAL_TXECHO</a>.</p>
<p>It is allowed to pass <code>NULL</code> as the value of <em>id</em>, <em>msg</em>, <em>dlc</em>, <em>flag</em>, and <em>time</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>A handle to an open circuit. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>Pointer to a buffer which receives the CAN identifier. This buffer will only get the identifier. To determine whether this identifier was standard (11-bit) or extended (29-bit), and/or whether it was remote or not, or if it was an error frame, examine the contents of the flag argument. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">msg</td><td>Pointer to the buffer which receives the message data. This buffer must be large enough (i.e. 8 bytes.). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dlc</td><td>Pointer to a buffer which receives the message length. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flag</td><td>Pointer to a buffer which receives the message flags, which is a combination of the canMSG_xxx and canMSGERR_xxx values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">time</td><td>Pointer to a buffer which receives the message time stamp. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>If no message is immediately available, this parameter gives the number of milliseconds to wait for a message before returning. 0xFFFFFFFF gives an infinite timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if a message was read. </dd>
<dd>
<a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a734089f351bc421c230bf8b6cd9b1e8e">canERR_NOMSG</a> (negative) if there was no message available. </dd>
<dd>
canERR_xxx (negative) if failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group___c_a_n.html#ga157d49a9343dea68ac953145e02266d8">canRead()</a>, <a class="el" href="group___c_a_n.html#ga16356f4d646240ff2e640773d21f4d76">canReadSync()</a></dd>
<dd>
<a class="el" href="page_user_guide_time_accuracy_and_resolution.html">Time Stamping Accuracy and Resolution</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cancount_8c-example.html#a8">cancount.c</a>, and <a class="el" href="canmonitor_8c-example.html#a8">canmonitor.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaecc8b56e75cf68548af53b2d432079af"></a><!-- doxytag: member="canlib.h::canResetBus" ref="gaecc8b56e75cf68548af53b2d432079af" args="(const CanHandle hnd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canResetBus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function tries to reset a CAN bus controller by taking the channel off bus and then on bus again (if it was on bus before the call to <a class="el" href="group___c_a_n.html#gaecc8b56e75cf68548af53b2d432079af">canResetBus()</a>.)</p>
<p>This function will affect the hardware (and cause a real reset of the CAN chip) only if <em>hnd</em> is the only handle open on the channel. If there are other open handles, this operation will not affect the hardware.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>A handle to an open circuit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if success </dd>
<dd>
canERR_xxx (negative) if failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group___c_a_n.html#ga99c7c99cc71580f8099a1407f4f9ea1a">canBusOn()</a>, <a class="el" href="group___c_a_n.html#gaf1786cfbfd542b18b9c599d278837bd9">canBusOff()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafca31590718ac7101d065b0c18b2410e"></a><!-- doxytag: member="canlib.h::canSetBusOutputControl" ref="gafca31590718ac7101d065b0c18b2410e" args="(const CanHandle hnd, const unsigned int drivertype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canSetBusOutputControl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>drivertype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the driver type for a CAN controller. This corresponds loosely to the bus output control register in the CAN controller, hence the name of this function. CANLIB does not allow for direct manipulation of the bus output control register; instead, symbolic constants are used to select the desired driver type.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Not all CAN driver types are supported on all cards.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>A handle to an open circuit. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">drivertype</td><td>Can driver type, <a class="el" href="canlib_8h.html#canDRIVER_xxx">canDRIVER_xxx</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if success </dd>
<dd>
canERR_xxx (negative) if failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group___c_a_n.html#ga1683419d56af8afdbfc9184678c82fdd">canGetBusOutputControl()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="canmonitor_8c-example.html#a5">canmonitor.c</a>, <a class="el" href="simplewrite_8c-example.html#a8">simplewrite.c</a>, and <a class="el" href="writeloop_8c-example.html#a5">writeloop.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga7eb8c2e92cfae57e7ec5031818524301"></a><!-- doxytag: member="canlib.h::canSetBusParams" ref="ga7eb8c2e92cfae57e7ec5031818524301" args="(const CanHandle hnd, long freq, unsigned int tseg1, unsigned int tseg2, unsigned int sjw, unsigned int noSamp, unsigned int syncmode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canSetBusParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tseg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tseg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sjw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>noSamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>syncmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the bus timing parameters for the specified CAN controller.</p>
<p>The library provides default values for <em>tseg1</em>, <em>tseg2</em>, <em>sjw</em> and <em>noSamp</em> when <em>freq</em> is specified to one of the pre-defined constants, <a class="el" href="canlib_8h.html#canBITRATE_xxx">canBITRATE_xxx</a>.</p>
<p>If <em>freq</em> is any other value, no default values are supplied by the library.</p>
<p>If you are using multiple handles to the same physical channel, for example if you are writing a threaded application, you must call <a class="el" href="group___c_a_n.html#gaf1786cfbfd542b18b9c599d278837bd9">canBusOff()</a> once for each handle. The same applies to <a class="el" href="group___c_a_n.html#ga99c7c99cc71580f8099a1407f4f9ea1a">canBusOn()</a> - the physical channel will not go off bus until the last handle to the channel goes off bus.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Use <a class="el" href="group___c_a_n.html#ga1a3ba0ef73eee6b97e886730ac696935">canSetBusParamsC200()</a> to set the bus timing parameters in the ubiquitous 82c200 bit-timing register format.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>An open handle to a CAN controller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Bit rate (measured in bits per second); or one of the predefined constants <a class="el" href="canlib_8h.html#canBITRATE_xxx">canBITRATE_xxx</a>, which are described below. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tseg1</td><td>Time segment 1, that is, the number of quanta from (but not including) the Sync Segment to the sampling point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tseg2</td><td>Time segment 2, that is, the number of quanta from the sampling point to the end of the bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sjw</td><td>The Synchronization Jump Width; can be 1,2,3, or 4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noSamp</td><td>The number of sampling points; can be 1 or 3. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">syncmode</td><td>Unsupported and ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if success </dd>
<dd>
canERR_xxx (negative) if failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="page_code_snippets_bit_rate.html">Bit Rate Examples</a>, <a class="el" href="page_user_guide_misc_bitrate.html">Bit Rate Constants</a>, <a class="el" href="page_user_guide_init_bit_rate.html">Bit Rate and Other Bus Parameters</a>, <a class="el" href="page_code_snippets_examples.html">Code Examples</a> </dd>
<dd>
<a class="el" href="group___c_a_n.html#ga1a3ba0ef73eee6b97e886730ac696935">canSetBusParamsC200()</a>, <a class="el" href="group___c_a_n.html#gaf2a734c0486030610389331685a3827a">canGetBusParams()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="busparms_8c-example.html#a5">busparms.c</a>, <a class="el" href="cancount_8c-example.html#a6">cancount.c</a>, <a class="el" href="canmonitor_8c-example.html#a4">canmonitor.c</a>, <a class="el" href="opentest_8c-example.html#a5">opentest.c</a>, <a class="el" href="simplewrite_8c-example.html#a7">simplewrite.c</a>, and <a class="el" href="writeloop_8c-example.html#a4">writeloop.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga1a3ba0ef73eee6b97e886730ac696935"></a><!-- doxytag: member="canlib.h::canSetBusParamsC200" ref="ga1a3ba0ef73eee6b97e886730ac696935" args="(const CanHandle hnd, BYTE btr0, BYTE btr1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canSetBusParamsC200 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="canlib_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td>
          <td class="paramname"><em>btr0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="canlib_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td>
          <td class="paramname"><em>btr1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the bus timing parameters using the same convention as the 82c200 CAN controller (which is the same as many other CAN controllers, for example, the 82527.)</p>
<p>To calculate the bit timing parameters, you can use the bit timing calculator that is included with CANLIB SDK. Look in the BIN directory.</p>
<p>82c200 Bit Timing</p>
<ul>
<li><em>btr0</em> [b7..b6]: SJW - 1 </li>
<li><em>btr0</em> [b5..b0]: Prescaler -1 </li>
<li><em>btr1</em> [b7]: <code>1</code>: 3 samples, <code>0</code>: 1 samples </li>
<li><em>btr1</em> [b6..b4]: tseg2 - 1 </li>
<li><em>btr1</em> [b3..b0]: tseg1 - 2</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>CANLIB will always behave as if the clock frequency is 16 MHz. It does not matter if the device has a different physical clock, since this will be compensated for by the driver.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>A handle to an open CAN circuit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">btr0</td><td>The desired bit timing, formatted as the contents of the BTR0 register in the 82c200. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">btr1</td><td>The desired bit timing, formatted as the contents of the BTR1 register in the 82c200.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if success </dd>
<dd>
canERR_xxx (negative) if failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="page_code_snippets_bit_rate.html">Bit Rate Examples</a>, <a class="el" href="page_user_guide_misc_bitrate.html">Bit Rate Constants</a> </dd>
<dd>
<a class="el" href="group___c_a_n.html#ga7eb8c2e92cfae57e7ec5031818524301">canSetBusParams()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5dd0f277c7059169055321fbda87486"></a><!-- doxytag: member="canlib.h::canSetNotify" ref="gaa5dd0f277c7059169055321fbda87486" args="(const CanHandle hnd, void(*callback)(canNotifyData *), unsigned int notifyFlags, void *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canSetNotify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structcan_notify_data.html">canNotifyData</a> *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>notifyFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function associates a callback function with the CAN circuit.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>A handle to an open CAN circuit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Handle to callback routine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notifyFlags</td><td>The events specified with canNOTIFY_xxx, for which callback should be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Pointer to user defined data. Passed to callback in the <a class="el" href="structcan_notify_data.html">canNotifyData</a> struct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if success </dd>
<dd>
canERR_xxx (negative) if failure </dd></dl>

</div>
</div>
<a class="anchor" id="gaf38b95fce4930347d9986887ec046e13"></a><!-- doxytag: member="canlib.h::canTranslateBaud" ref="gaf38b95fce4930347d9986887ec046e13" args="(long *const freq, unsigned int *const tseg1, unsigned int *const tseg2, unsigned int *const sjw, unsigned int *const nosamp, unsigned int *const syncMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canTranslateBaud </td>
          <td>(</td>
          <td class="paramtype">long *const&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *const&#160;</td>
          <td class="paramname"><em>tseg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *const&#160;</td>
          <td class="paramname"><em>tseg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *const&#160;</td>
          <td class="paramname"><em>sjw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *const&#160;</td>
          <td class="paramname"><em>nosamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *const&#160;</td>
          <td class="paramname"><em>syncMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function translates the <a class="el" href="canlib_8h.html#canBITRATE_xxx">canBITRATE_xxx</a> constants to their corresponding bus parameter values. At return, this <em>freq</em> contains the actual bit rate (in bits per second). <em>TSeg1</em> is the number of quanta (less one) in a bit before the sampling point. <em>TSeg2</em> is the number of quanta after the sampling point.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>A pointer to a <code>DWORD</code> which contains the <a class="el" href="canlib_8h.html#canBITRATE_xxx">canBITRATE_xxx</a> constant to translate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tseg1</td><td>A pointer to a buffer which receives the Time segment 1, that is, the number of quanta from (but not including) the Sync Segment to the sampling point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tseg2</td><td>A pointer to a buffer which receives the Time segment 2, that is, the number of quanta from the sampling point to the end of the bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sjw</td><td>A pointer to a buffer which receives the Synchronization Jump Width; can be 1,2,3, or 4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nosamp</td><td>A pointer to a buffer which receives the number of sampling points; can be 1 or 3. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">syncMode</td><td>Unsupported, always read as zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if success </dd>
<dd>
canERR_xxx (negative) if failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group___c_a_n.html#ga7eb8c2e92cfae57e7ec5031818524301">canSetBusParams()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga62c185329d6741c90102511e2f37983e"></a><!-- doxytag: member="canlib.h::canWrite" ref="ga62c185329d6741c90102511e2f37983e" args="(const CanHandle hnd, long id, void *msg, unsigned int dlc, unsigned int flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canWrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dlc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sends a CAN message. The call returns immediately after queuing the message to the driver.</p>
<p>If you are using the same channel via multiple handles, note that the default behaviour is that the different handles will "hear" each other just as if each handle referred to a channel of its own. If you open, say, channel 0 from thread A and thread B and then send a message from thread A, it will be "received" by thread B. This behaviour can be changed using <a class="el" href="canlib_8h.html#a86f7ce6c809f30983b69ead49d793689">canIOCTL_SET_LOCAL_TXECHO</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The message has been queued for transmission when this calls return. It has not necessarily been sent.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>A handle to an open CAN circuit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The identifier of the CAN message to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>A pointer to the message data, or <code>NULL</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dlc</td><td>The length of the message. Can be at most 8. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>A combination of message flags, canMSG_xxx. Use this parameter to send extended (29-bit) frames and/or remote frames. Use <a class="el" href="canstat_8h.html#ade936f23b4b303d64187b4c6589c9c10">canMSG_EXT</a> and/or <a class="el" href="canstat_8h.html#a687df04559a9995e0bec503655454eb3">canMSG_RTR</a> for this purpose.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if success </dd>
<dd>
canERR_xxx (negative) if failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="page_user_guide_send_recv_sending.html">Sending Messages</a>, <a class="el" href="page_code_snippets_examples.html">Code Examples</a> </dd>
<dd>
<a class="el" href="group___c_a_n.html#ga304cb3a7bc2874c1f8ad361a911bcd5f">canWriteSync()</a>, <a class="el" href="group___c_a_n.html#ga47d03bfcc31e290284e65211b61f15f3">canWriteWait()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="simplewrite_8c-example.html#a11">simplewrite.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga304cb3a7bc2874c1f8ad361a911bcd5f"></a><!-- doxytag: member="canlib.h::canWriteSync" ref="ga304cb3a7bc2874c1f8ad361a911bcd5f" args="(const CanHandle hnd, unsigned long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canWriteSync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Waits until all CAN messages for the specified handle are sent, or the timeout period expires.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>A handle to an open CAN circuit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>The timeout in milliseconds. 0xFFFFFFFF gives an infinite timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if the queue emptied before the timeout period came to its end. </dd>
<dd>
<a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7acd1c4c3a87dd24f0a43753ee4bfe7993">canERR_TIMEOUT</a> (negative) not all messages were transmitted when the timeout occurred. </dd>
<dd>
<a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7ae22cf05933b31e181f580ee702006f26">canERR_PARAM</a> (negative) This could be caused by an erroneous parameter, or if you have turned TXACKs off (by using <a class="el" href="group___general.html#gaeaa24db97af22478ca51d48636c7bb12">canIoCtl()</a>) because if you do you can't use this call. The driver simply doesn't know when all the messages are sent! </dd>
<dd>
canERR_xxx (negative) if failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group___c_a_n.html#ga62c185329d6741c90102511e2f37983e">canWrite()</a>, <a class="el" href="group___c_a_n.html#ga47d03bfcc31e290284e65211b61f15f3">canWriteWait()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="simplewrite_8c-example.html#a12">simplewrite.c</a>, and <a class="el" href="writeloop_8c-example.html#a10">writeloop.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga47d03bfcc31e290284e65211b61f15f3"></a><!-- doxytag: member="canlib.h::canWriteWait" ref="ga47d03bfcc31e290284e65211b61f15f3" args="(const CanHandle hnd, long id, void *msg, unsigned int dlc, unsigned int flag, unsigned long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7">canStatus</a> canWriteWait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="canlib_8h.html#a75f2e3a4c7b1e47c8c6b25b76975b510">CanHandle</a>&#160;</td>
          <td class="paramname"><em>hnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dlc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sends a CAN message. It returns when the message is sent, or the timeout expires.</p>
<p>This is a convenience function that combines <a class="el" href="group___c_a_n.html#ga62c185329d6741c90102511e2f37983e">canWrite()</a> and <a class="el" href="group___c_a_n.html#ga304cb3a7bc2874c1f8ad361a911bcd5f">canWriteSync()</a>.</p>
<p>If you are using the same channel via multiple handles, note that the default behaviour is that the different handles will "hear" each other just as if each handle referred to a channel of its own. If you open, say, channel 0 from thread A and thread B and then send a message from thread A, it will be "received" by thread B. This behaviour can be changed using <a class="el" href="canlib_8h.html#a86f7ce6c809f30983b69ead49d793689">canIOCTL_SET_LOCAL_TXECHO</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hnd</td><td>A handle to an open CAN circuit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The identifier of the CAN message to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>A pointer to the message data, or <code>NULL</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dlc</td><td>The length of the message. Can be at most 8. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>A combination of message flags, canMSG_xxx. Use this parameter to send extended (29-bit) frames and/or remote frames. Use <a class="el" href="canstat_8h.html#ade936f23b4b303d64187b4c6589c9c10">canMSG_EXT</a> and/or <a class="el" href="canstat_8h.html#a687df04559a9995e0bec503655454eb3">canMSG_RTR</a> for this purpose. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>The timeout, in milliseconds. 0xFFFFFFFF gives an infinite timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> (zero) if success </dd>
<dd>
canERR_xxx (negative) if failure </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="writeloop_8c-example.html#a8">writeloop.c</a>.</dd>
</dl>
</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<!-- <hr class="footer"/> -->
<address class="footer">
<small>Kvaser Linux CANLIB (canlib 5.9) - Generated on Tue Mar 17 2015</small>
</address>
</body>
</html>
